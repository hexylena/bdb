\begin{columns}[t]
\separatorcolumn

\begin{column}{\colwidth}

  \begin{block}{Abstract}
    \large Students have a poor working model of code which leads to numerous issues:
    they struggle to debug, to adjust copy-pasted code, and to predict runtime
    behaviour.

    Existing research provides a number of avenues for improving our coding education and improving the student experience. Here we discuss a number of strategies to enhance student learning, provide a deeper understanding of code, and improve the student mental model of code execution. This should allow students to thrive as budding coders.

    \begin{figure}[ht]
        \centering
        \includegraphics[width=\textwidth]{pair-programming.jpg}
        \caption{Pair programming has two participants join forces to develop solutions, one leading the effort, one writing the code. (Image: StartupStockPhotos.com / CC0)}
        \label{fig:pair}
    \end{figure}
  \end{block}

  \begin{block}{de Probleemstelling}
    Currently students finish the course with a moderate working understanding of
    code, not sufficient to write their own programs or adapt new code to their
    situation. This is an extremely suboptimal outcome, after 8 weeks they
    should be able to write moderately complex python programs.

    Showing what happens live on the screen is received well by students, if
    they can manage to watch what we type and try to type it themselves
    simultaneously. We know at least that our examples give the correct result,
    but students never see anything other than correct, working code, and never
    have to formulate an internal model for how to write code. They end up
    copying and pasting and not understanding \emph{why}. As of now nothing is going
    ``well'', and there is room for improvement in all aspects, but specifically
    this discussion will focus on improving mental models of code and the
    potential effects on understanding code execution.

    Predicting code behaviour without running it is a key component of work as a
    programmer, and a lot of the time we spend debugging relies on us emulating
    the computer in our head. Without a solid mental model of code behaviour
    one cannot predict how it will function in one situation, much less other or
    non-standard situations. Planning for code to handle both good and bad
    inputs requires some creativity and mentally planning around expected values
    at various points throughout the execution.

    This situation leaves students unprepared for incorrect or buggy code,
    either (un)intentionally included in homework assignments, or, generated by
    themselves, if they cannot identify where code will fail without executing
    it.

  \end{block}

  \begin{block}{de Conclusie}
    Students must develop a coherent and strong internal model of code execution
    to allow them to understand code flow, fix broken code, and debug issues.
  \end{block}

  \begin{alertblock}{de Hypothese}
    \large Augmenting lessons with:

  \begin{enumerate}
    \item Tracing - Stepping through the internal state
    \item Faded examples
    \item Debugging intentionally broken examples
  \end{enumerate}

    Will give students enough tools to respond dynamically to failure
    states with informed experience to resolve issues they encounter as programmers.
  \end{alertblock}

  \begin{block}{de Verbetermogelijkheden}
    \heading{Mental Model}
    The student's mental model of the code underlies everything they do as a programmer, from conception to implementation to debugging to their self efficacy:

      \begin{quote}
This study shows that a well-developed and accurate mental model directly
affects course performance and also increases self efficacy, the other key
element in course performance. Given this double impact, helping students
develop good mental models should remain a goal in introductory programming
courses.\cite{Ramalingam_2004}
    \end{quote}

      This is a foundational skill to be able to \emph{think} through a program, step by step, and understand how the code executes and which variables exist when, and what their values should be. This mental modelling allows students to predict the behaviour of a system, and when it diverges from their prediction, recognise any potential bugs.

  \end{block}

\end{column}

\separatorcolumn

\begin{column}{\colwidth}
    \begin{block}{de Verbetermogelijkheden (Cont.)}


    \heading{Tracing}
\begin{figure}[ht]
\begin{minipage}[b]{0.65\linewidth}
\begin{lstlisting}
# Initialise our accumulator
x = 1 + 1
# Loop over our input data
for i in range(10): # 0..9
    # In-loop temporary variable
    tmp = x * 2 + i
    # Update our accumulator
    x = tmp + 1
# Output our result
print(f'The final value is {x}')
\end{lstlisting}
\caption{Example Python Code. While not representative of a real world workflow, it is useful as an illustrative example, and an example which can be given directly to beginners for them to attempt.\label{fig:code}}
\end{minipage}
\hspace{0.5cm}
\begin{minipage}[b]{0.25\linewidth}
    \begin{tabular}{r|lll}
        Line & \texttt{i} & \texttt{x} & \texttt{tmp} \\\hline
        2    & -          & 2          & - \\
        4    & 0          & 2          & - \\
        6    & 0          & 2          & 4 \\
        8    & 0          & 5          & 4 \\
        4    & 1          & 5          & - \\
        6    & 1          & 5          & 11 \\
        8    & 1          & 12         & 11 \\
        4    & 2          & 12         & - \\
        6    & 2          & 12         & 26 \\
        8    & 2          & 27         & 26 \\
\end{tabular}
\caption{Example of a student's process tracing execution flow}
\label{fig:table}
\end{minipage}
\end{figure}

      While there is no bug in \cref{fig:code}, when there \emph{is} a bug present, having students produce a table like \cref{fig:table} significantly improves their understanding of code flow and execution\cite{Hertz_2013}. ``Tracing'' is a valuable and easy to complete exercise, and the results can even be checked automatically leading to good scalability of the exercise across larger classes.

    \heading{Faded Examples}
      Given that the students taught by Avans are primarily novice programmers who have not read or written a programming language before, we need to take significant care of their cognitive load. Both learning based on problem-solving and worked examples may cause high cognitive loads for different audiences, and exploring alternatives is important\cite{Retnowati_2017}. Faded examples such as what is seen in \cref{fig:fade} are exactly such an alternative, starting with a fully worked example and removing successive components until we reach a problem description requiring a full solution. This leads to fewer unproductive learning events\cite{Renkl_2004}.

\begin{figure}[ht]
    \begin{minipage}[b]{\linewidth}
\begin{lstlisting}
# Write a function that multiplies two numbers
def multiply(a, b):
    c = a * b
    return c
\end{lstlisting}
    %\caption{The initial problem shows the entire solution to students}
    \end{minipage}

    \begin{minipage}[b]{\linewidth}
\begin{lstlisting}
# Write a function that adds two numbers
def add(___):
    ____
    return c
\end{lstlisting}
        %\caption{Increased fading, here we call out blanks students should fill in specifically with syntactically incorrect underscores.}
    \end{minipage}

    \begin{minipage}[b]{\linewidth}
\begin{lstlisting}
# Write a function that subtracts two numbers
\end{lstlisting}
    %\caption{Final fading, the entire problem is gone except for the description of what they need to do.}
    \end{minipage}

  \caption{Example of fading in coding exercises, these let students work on a continuum from worked out examples to self-devised solutions.\label{fig:fade}}
\end{figure}

Faded examples however, do come at a higher cost of implementation than worked out examples\cite{Zamary_2018}. They require writing the correct worked out example and then determining which components to remove, which presents an additional cost during course updates that if examples are changed they need to be double checked to ensure they are still valid, whereas worked examples can be checked more automatically.


    \heading{Debugging}
        Debugging is the act of identify and resolving ``bugs'' or defects within code, a term popularly attributed to my personal hero Admiral Grace Hopper:

        \begin{quote}
            While she was working on a Mark II computer at Harvard University, her associates discovered a moth stuck in a relay and thereby impeding operation, whereupon she remarked that they were ``debugging'' the system\cite{enwiki:1069955193}
        \end{quote}

      Debugging also functions as a reinforcement method we can use once students have an ok mental model of code execution, a necessary pre-requisite for this activity, which can be further developed through debugging\cite{Ramalingam_2004} alongside their self-efficacy\cite{Michaeli_2019}. Debugging activities can take many forms but most commonly the task is to correct incorrect code, an activity that works best if they are primed with a number of methods of debugging\cite{Murphy_2008} such as the ``Wolf Fence''\cite{Gauss_1982}, commenting out code, or breakpoints.

      \begin{figure}[]
\begin{lstlisting}
# Fix me!
for number in range(10):
    # use a if the number is a multiple of 3, otherwise use b
    if Number \% 3 == 0:
        message = message + a
    else:
        message = message + "b"
print(message)
\end{lstlisting}
          \caption{A debugging exercise featuring code with numerous issues from type confusion, variable typos, and failure to initialise a variable.\label{fig:debug}}
      \end{figure}
  \end{block}



    \heading{Pair Programming}
        Complementary to the efforts of Mental Model development via Tracing/Debugging/Fading, pair programming or ``pairing'' (\cref{fig:pair}) provides a reinforcement activity where they utilise similar skills. As one person writes and executes code, the other person `drives' the experience, telling them what to write\cite{Williams,Williams_2001}. It has become a common learning model in introductory courses due to its benefits to students\cite{mendes2005investigating,mendes2006replicated,Hannay_2007}. Specifically this technique has also been shown to be beneficial for women in computer science and gives them better chances for success in future programming endeavours\cite{werner2004pair}. Adopting this technique already (Assignment 6) has shown initially promising results, provided we adhere to principles outlined by \cite{Mentz_2008}.

\end{column}

\separatorcolumn

\begin{column}{\colwidth}

  \begin{exampleblock}{de Interventie}
      The intervention will consist of overhauling the formative assessments that students complete during class to include these new types of problems in the daily curriculum. The example code listings provided (\cref{fig:code,fig:fade,fig:debug}) are representative of the updates to formative assessments that we will make.

      \begin{enumerate}
% whenever they want 2 reasons, one must be a physical improvement, and the other must be a psychological improvement. so as long as number 1 is something about physical /performance , and number 2 is about confidence, self-awareness, motivation and so on, you cover the points

          \item This intervention is well backed by research showing improvements in student proficiency and grades\cite{Hertz_2013,Renkl_2002} leading to better learning outcomes\cite{Renkl_2004}.
          \item These skills significantly improve self efficacy\cite{Ramalingam_2004,Michaeli_2019}.
      \end{enumerate}

      The second point, lack of self-efficacy has been a significant cost for TOAs and teachers alike in terms of interruptions for questions students should be able to answer on their own, and by applying these interventions hopefully students will find themselves and peers a more reliable source of discussion and answers. Self empowerment in this field sets the students on a good path for their future.

    \title{Assessment}

      It is difficult to conduct a sufficiently controlled experiment given individual teacher preferences and teaching styles, so assessment will be carried out via review of student homework solutions. The system we use that collects student homework submission tracks student code entry over time, and will let us review how they attempted solutions and let us make qualitative observations.

  \end{exampleblock}

  \begin{block}{het Verwachte Resultaat}
    \begin{wrapfigure}{R}{0.52\textwidth}
\centering
      \includegraphics[width=0.48\textwidth]{./primm.png}
          \caption{Diagram of the PRIMM methodology\cite{Sentance_2017}, a model incorporating all of these activities that is used in K-12 teaching. A mental model is required to predict, tracing for investigation, debugging to modify.\label{fig:primm}}
\end{wrapfigure}
    Unfortunately there was not sufficient time to trial all of these strategies and evaluate the sections. Instead, all of these are currently being trialled in Group 32MBI02, please check back at the end of P3 for results. It is expected that these research backed teaching strategies will significantly improve student learning.
      \vspace{8em}


  \end{block}

  \begin{block}{de Bibliografie}
    \nocite{*}
    \footnotesize{\bibliographystyle{plain}\bibliography{poster}}

  \end{block}

\end{column}

\separatorcolumn
\end{columns}
